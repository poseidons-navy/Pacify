import { Json, MaybePromise, FileRouterInputKey, ContentDisposition, ErrorMessage, FileRouterInputConfig, UploadThingError, FetchEsque, Simplify } from '@uploadthing/shared';
import { FileUploadDataWithCustomId, FileUploadData, UploadedFileData } from '../types/index.js';

type LogLevel = "error" | "warn" | "info" | "debug" | "trace";

type ParseFn<TType> = (input: unknown) => MaybePromise<TType>;
type ParserZodEsque<TInput, TParsedInput extends Json> = {
    _input: TInput;
    _output: TParsedInput;
    parse: ParseFn<TParsedInput>;
};
type JsonParser = ParserZodEsque<Json, Json>;

interface PresignedBase {
    key: string;
    fileName: string;
    fileType: FileRouterInputKey;
    fileUrl: string;
    contentDisposition: ContentDisposition;
    pollingJwt: string;
    pollingUrl: string;
    customId: string | null;
}
interface PSPResponse extends PresignedBase {
    url: string;
    fields: Record<string, string>;
}
interface MPUResponse extends PresignedBase {
    urls: string[];
    uploadId: string;
    chunkSize: number;
    chunkCount: number;
}
/**
 * Returned by `/api/prepareUpload` and `/api/uploadFiles`
 */
type PresignedURLs = (PSPResponse | MPUResponse)[];
/**
 * Marker used to append a `customId` to the incoming file data in `.middleware()`
 * @example
 * ```ts
 * .middleware((opts) => {
 *   return {
 *     [UTFiles]: opts.files.map((file) => ({
 *       ...file,
 *       customId: generateId(),
 *     }))
 *   };
 * })
 * ```
 */
declare const UTFiles: unique symbol;
declare const unsetMarker: "unsetMarker" & {
    __brand: "unsetMarker";
};
type UnsetMarker = typeof unsetMarker;
type ValidMiddlewareObject = {
    [UTFiles]?: Partial<FileUploadDataWithCustomId>[];
    [key: string]: unknown;
};
type ResolverOptions<TParams extends AnyParams> = {
    metadata: Simplify<TParams["_metadata"] extends UnsetMarker ? undefined : Omit<TParams["_metadata"], typeof UTFiles>>;
    file: UploadedFileData;
};
/**
 * Different frameworks have different request and response types
 */
type MiddlewareFnArgs<TRequest, TResponse, TEvent> = {
    req: TRequest;
    res: TResponse;
    event: TEvent;
};
interface AnyParams {
    _input: any;
    _metadata: any;
    _middlewareArgs: MiddlewareFnArgs<any, any, any>;
    _errorShape: any;
    _errorFn: any;
    _output: any;
}
type MiddlewareFn<TInput extends Json | UnsetMarker, TOutput extends ValidMiddlewareObject, TArgs extends MiddlewareFnArgs<any, any, any>> = (opts: TArgs & {
    files: FileUploadData[];
    input: TInput extends UnsetMarker ? undefined : TInput;
}) => MaybePromise<TOutput>;
type ResolverFn<TOutput extends Json | void, TParams extends AnyParams> = (opts: ResolverOptions<TParams>) => MaybePromise<TOutput>;
type UploadErrorFn = (input: {
    error: UploadThingError;
    fileKey: string;
}) => void;
interface UploadBuilder<TParams extends AnyParams> {
    input: <TParser extends JsonParser>(parser: TParams["_input"] extends UnsetMarker ? TParser : ErrorMessage<"input is already set">) => UploadBuilder<{
        _input: TParser["_output"];
        _metadata: TParams["_metadata"];
        _middlewareArgs: TParams["_middlewareArgs"];
        _errorShape: TParams["_errorShape"];
        _errorFn: TParams["_errorFn"];
        _output: UnsetMarker;
    }>;
    middleware: <TOutput extends ValidMiddlewareObject>(fn: TParams["_metadata"] extends UnsetMarker ? MiddlewareFn<TParams["_input"], TOutput, TParams["_middlewareArgs"]> : ErrorMessage<"middleware is already set">) => UploadBuilder<{
        _input: TParams["_input"];
        _metadata: TOutput;
        _middlewareArgs: TParams["_middlewareArgs"];
        _errorShape: TParams["_errorShape"];
        _errorFn: TParams["_errorFn"];
        _output: UnsetMarker;
    }>;
    onUploadComplete: <TOutput extends Json | void>(fn: ResolverFn<TOutput, TParams>) => Uploader<{
        _input: TParams["_input"];
        _metadata: TParams["_metadata"];
        _middlewareArgs: TParams["_middlewareArgs"];
        _errorShape: TParams["_errorShape"];
        _errorFn: TParams["_errorFn"];
        _output: TOutput;
    }>;
    onUploadError: (fn: TParams["_errorFn"] extends UnsetMarker ? UploadErrorFn : ErrorMessage<"onUploadError is already set">) => UploadBuilder<{
        _input: TParams["_input"];
        _metadata: TParams["_metadata"];
        _middlewareArgs: TParams["_middlewareArgs"];
        _errorShape: TParams["_errorShape"];
        _errorFn: UploadErrorFn;
        _output: UnsetMarker;
    }>;
}
type UploadBuilderDef<TParams extends AnyParams> = {
    routerConfig: FileRouterInputConfig;
    inputParser: JsonParser;
    middleware: MiddlewareFn<TParams["_input"], {}, TParams["_middlewareArgs"]>;
    errorFormatter: (err: UploadThingError) => TParams["_errorShape"];
    onUploadError: UploadErrorFn;
};
interface Uploader<TParams extends AnyParams> {
    _def: TParams & UploadBuilderDef<TParams>;
    resolver: ResolverFn<TParams["_output"], TParams>;
}
type FileRouter<TParams extends AnyParams = AnyParams> = Record<string, Uploader<TParams>>;
type RouteHandlerConfig = {
    logLevel?: LogLevel;
    callbackUrl?: string;
    uploadthingId?: string;
    uploadthingSecret?: string;
    /**
     * Used to determine whether to run dev hook or not
     * @default `env.NODE_ENV === "development" || env.NODE_ENV === "dev"`
     */
    isDev?: boolean;
    /**
     * Used to override the fetch implementation
     * @default `globalThis.fetch`
     */
    fetch?: FetchEsque;
};
type RouteHandlerOptions<TRouter extends FileRouter> = {
    router: TRouter;
    config?: RouteHandlerConfig;
};
type RequestHandlerInput<TArgs extends MiddlewareFnArgs<any, any, any>> = {
    req: Request;
    middlewareArgs: TArgs;
};
type RequestHandlerOutput = Promise<{
    status: number;
    body: UTEvents[keyof UTEvents]["out"];
    cleanup?: Promise<unknown>;
} | UploadThingError>;
type RequestHandler<TArgs extends MiddlewareFnArgs<any, any, any>> = (input: RequestHandlerInput<TArgs>) => RequestHandlerOutput;
type inferEndpointInput<TUploader extends Uploader<any>> = TUploader["_def"]["_input"] extends UnsetMarker ? undefined : TUploader["_def"]["_input"];
type inferEndpointOutput<TUploader extends Uploader<any>> = TUploader["_def"]["_output"] extends UnsetMarker | void | undefined ? null : TUploader["_def"]["_output"];
type inferErrorShape<TRouter extends FileRouter> = TRouter[keyof TRouter]["_def"]["_errorShape"];
/**
 * Valid options for the `?actionType` query param
 */
declare const VALID_ACTION_TYPES: readonly ["upload", "failure", "multipart-complete"];
type ActionType = (typeof VALID_ACTION_TYPES)[number];
/**
 * Map actionType to the required payload for that action
 */
type UTEvents = {
    upload: {
        in: {
            files: FileUploadData[];
            input: Json;
        };
        out: PresignedURLs;
    };
    failure: {
        in: {
            fileKey: string;
            uploadId: string | null;
            s3Error?: string;
            fileName: string;
        };
        out: null;
    };
    "multipart-complete": {
        in: {
            fileKey: string;
            uploadId: string;
            etags: {
                tag: string;
                partNumber: number;
            }[];
        };
        out: null;
    };
};

export { type ActionType, type AnyParams, type FileRouter, type MPUResponse, type MiddlewareFnArgs, type PSPResponse, type PresignedBase, type PresignedURLs, type RequestHandler, type RouteHandlerConfig, type RouteHandlerOptions, type UTEvents, UTFiles, type UnsetMarker, type UploadBuilder, type UploadBuilderDef, type Uploader, VALID_ACTION_TYPES, type ValidMiddlewareObject, type inferEndpointInput, type inferEndpointOutput, type inferErrorShape };
