import { fromEvent } from 'file-selector';
import { onMount } from 'svelte';
import { writable, derived, get } from 'svelte/store';
import { acceptPropAsAcceptAttr, initialState, reducer, isEventWithFiles, allFilesAccepted, noop, isEnterOrSpace, isIeOrEdge, isFileAccepted, isValidSize, isValidQuantity } from '@uploadthing/dropzone/core';

function reducible(reducer, state) {
    const { update, subscribe } = writable(state);
    const dispatch = (action)=>update((state)=>reducer(state, action));
    return [
        {
            subscribe
        },
        dispatch
    ];
}
function createDropzone(_props) {
    const props = writable({
        disabled: false,
        maxSize: Number.POSITIVE_INFINITY,
        minSize: 0,
        multiple: true,
        maxFiles: 0,
        ..._props
    });
    const acceptAttr = derived(props, ($props)=>acceptPropAsAcceptAttr($props.accept));
    const rootRef = writable();
    const inputRef = writable();
    let dragTargets = [];
    const [state, dispatch] = reducible(reducer, initialState);
    onMount(()=>{
        const onWindowFocus = ()=>{
            if (get(state).isFileDialogActive) {
                setTimeout(()=>{
                    const input = get(inputRef);
                    if (input) {
                        const { files } = input;
                        if (!files?.length) {
                            dispatch({
                                type: "closeDialog"
                            });
                        }
                    }
                }, 300);
            }
        };
        window.addEventListener("focus", onWindowFocus, false);
        return ()=>{
            window.removeEventListener("focus", onWindowFocus, false);
        };
    });
    onMount(()=>{
        const onDocumentDrop = (event)=>{
            const root = get(rootRef);
            if (root?.contains(event.target)) {
                // If we intercepted an event for our instance, let it propagate down to the instance's onDrop handler
                return;
            }
            event.preventDefault();
            dragTargets = [];
        };
        const onDocumentDragOver = (e)=>e.preventDefault();
        document.addEventListener("dragover", onDocumentDragOver, false);
        document.addEventListener("drop", onDocumentDrop, false);
        return ()=>{
            document.removeEventListener("dragover", onDocumentDragOver, false);
            document.removeEventListener("drop", onDocumentDrop, false);
        };
    });
    const isPropagationStopped = (event)=>{
        if (typeof event.cancelBubble !== "undefined") {
            return event.cancelBubble;
        }
        return false;
    };
    const onDragEnter = (event)=>{
        event.preventDefault();
        dragTargets = [
            ...dragTargets,
            event.target
        ];
        if (isEventWithFiles(event)) {
            Promise.resolve(fromEvent(event)).then((files)=>{
                if (isPropagationStopped(event)) return;
                const fileCount = files.length;
                const isDragAccept = fileCount > 0 && allFilesAccepted({
                    files: files,
                    accept: get(acceptAttr),
                    minSize: get(props).minSize,
                    maxSize: get(props).maxSize,
                    multiple: get(props).multiple,
                    maxFiles: get(props).maxFiles
                });
                const isDragReject = fileCount > 0 && !isDragAccept;
                dispatch({
                    type: "setDraggedFiles",
                    payload: {
                        isDragAccept,
                        isDragReject,
                        isDragActive: true
                    }
                });
            }).catch(noop);
        }
    };
    const onDragOver = (event)=>{
        event.preventDefault();
        event.stopPropagation();
        const hasFiles = isEventWithFiles(event);
        if (hasFiles && event.dataTransfer) {
            try {
                event.dataTransfer.dropEffect = "copy";
            } catch  {
                noop();
            }
        }
        return false;
    };
    const onDragLeave = (event)=>{
        event.preventDefault();
        event.stopPropagation();
        const root = get(rootRef);
        // Only deactivate once the dropzone and all children have been left
        const targets = dragTargets.filter((target)=>root?.contains(target));
        // Make sure to remove a target present multiple times only once
        // (Firefox may fire dragenter/dragleave multiple times on the same element)
        const targetIdx = targets.indexOf(event.target);
        if (targetIdx !== -1) {
            targets.splice(targetIdx, 1);
        }
        dragTargets = targets;
        if (targets.length > 0) {
            return;
        }
        dispatch({
            type: "setDraggedFiles",
            payload: {
                isDragActive: false,
                isDragAccept: false,
                isDragReject: false
            }
        });
    };
    const setFiles = (files)=>{
        const acceptedFiles = [];
        files.forEach((file)=>{
            const accepted = isFileAccepted(file, get(acceptAttr));
            const sizeMatch = isValidSize(file, get(props).minSize, get(props).maxSize);
            if (accepted && sizeMatch) {
                acceptedFiles.push(file);
            }
        });
        if (!isValidQuantity(acceptedFiles, get(props).multiple, get(props).maxFiles)) {
            acceptedFiles.splice(0);
        }
        dispatch({
            type: "setFiles",
            payload: {
                acceptedFiles
            }
        });
        get(props).onDrop(acceptedFiles);
    };
    const onDropCb = (event)=>{
        event.preventDefault();
        dragTargets = [];
        if (isEventWithFiles(event)) {
            Promise.resolve(fromEvent(event)).then((files)=>{
                if (isPropagationStopped(event)) {
                    return;
                }
                setFiles(files);
            }).catch(noop);
        }
        dispatch({
            type: "reset"
        });
    };
    const openFileDialog = ()=>{
        const input = get(inputRef);
        if (input) {
            dispatch({
                type: "openDialog"
            });
            input.value = "";
            input.click();
        }
    };
    const onKeyDown = (event)=>{
        // Ignore keyboard events bubbling up the DOM tree
        const root = get(rootRef);
        if (!root?.isEqualNode(event.target)) {
            return;
        }
        if (isEnterOrSpace(event)) {
            event.preventDefault();
            openFileDialog();
        }
    };
    const onInputElementClick = (event)=>{
        event.stopPropagation();
    };
    const onFocus = ()=>dispatch({
            type: "focus"
        });
    const onBlur = ()=>dispatch({
            type: "blur"
        });
    const onClick = ()=>{
        // In IE11/Edge the file-browser dialog is blocking, therefore, use setTimeout()
        // to ensure React can handle state changes
        // See: https://github.com/react-dropzone/react-dropzone/issues/450
        isIeOrEdge() ? setTimeout(openFileDialog, 0) : openFileDialog();
    };
    // This is a svelte action, it should be used as "use:dropzoneRoot"
    // We should be able to refactor this when svelte 5 is released to bring it more inline
    // with the rest of the dropzone implementations
    const dropzoneRoot = (node)=>{
        rootRef.set(node);
        node.setAttribute("role", "presentation");
        if (!get(props).disabled) {
            node.setAttribute("tabIndex", "0");
            node.addEventListener("keydown", onKeyDown);
            node.addEventListener("focus", onFocus);
            node.addEventListener("blur", onBlur);
            node.addEventListener("click", onClick);
            node.addEventListener("dragenter", onDragEnter);
            node.addEventListener("dragover", onDragOver);
            node.addEventListener("dragleave", onDragLeave);
            node.addEventListener("drop", onDropCb);
        }
        return {
            destroy () {
                rootRef.set(null);
                node.removeEventListener("keydown", onKeyDown);
                node.removeEventListener("focus", onFocus);
                node.removeEventListener("blur", onBlur);
                node.removeEventListener("click", onClick);
                node.removeEventListener("dragenter", onDragEnter);
                node.removeEventListener("dragover", onDragOver);
                node.removeEventListener("dragleave", onDragLeave);
                node.removeEventListener("drop", onDropCb);
            }
        };
    };
    // This is a svelte action, it should be used as "use:dropzoneInput"
    const dropzoneInput = (node, options)=>{
        inputRef.set(node);
        node.setAttribute("type", "file");
        node.style.display = "none";
        node.setAttribute("multiple", String(options.multiple));
        node.setAttribute("tabIndex", "-1");
        const acceptAttrUnsub = acceptAttr.subscribe((accept)=>{
            node.setAttribute("accept", accept);
        });
        if (!options.disabled) {
            node.addEventListener("change", onDropCb);
            node.addEventListener("click", onInputElementClick);
        }
        return {
            update (options) {
                props.update(($props)=>({
                        ...$props,
                        ...options
                    }));
                node.setAttribute("multiple", String(options.multiple));
            },
            destroy () {
                inputRef.set(null);
                acceptAttrUnsub();
                node.removeEventListener("change", onDropCb);
                node.removeEventListener("click", onInputElementClick);
            }
        };
    };
    return {
        state,
        dropzoneRoot,
        dropzoneInput,
        rootRef
    };
}

export { createDropzone };
