Object.defineProperty(exports, '__esModule', { value: true });

var fileSelector = require('file-selector');
var svelte = require('svelte');
var store = require('svelte/store');
var core = require('@uploadthing/dropzone/core');

function reducible(reducer, state) {
    const { update, subscribe } = store.writable(state);
    const dispatch = (action)=>update((state)=>reducer(state, action));
    return [
        {
            subscribe
        },
        dispatch
    ];
}
function createDropzone(_props) {
    const props = store.writable({
        disabled: false,
        maxSize: Number.POSITIVE_INFINITY,
        minSize: 0,
        multiple: true,
        maxFiles: 0,
        ..._props
    });
    const acceptAttr = store.derived(props, ($props)=>core.acceptPropAsAcceptAttr($props.accept));
    const rootRef = store.writable();
    const inputRef = store.writable();
    let dragTargets = [];
    const [state, dispatch] = reducible(core.reducer, core.initialState);
    svelte.onMount(()=>{
        const onWindowFocus = ()=>{
            if (store.get(state).isFileDialogActive) {
                setTimeout(()=>{
                    const input = store.get(inputRef);
                    if (input) {
                        const { files } = input;
                        if (!files?.length) {
                            dispatch({
                                type: "closeDialog"
                            });
                        }
                    }
                }, 300);
            }
        };
        window.addEventListener("focus", onWindowFocus, false);
        return ()=>{
            window.removeEventListener("focus", onWindowFocus, false);
        };
    });
    svelte.onMount(()=>{
        const onDocumentDrop = (event)=>{
            const root = store.get(rootRef);
            if (root?.contains(event.target)) {
                // If we intercepted an event for our instance, let it propagate down to the instance's onDrop handler
                return;
            }
            event.preventDefault();
            dragTargets = [];
        };
        const onDocumentDragOver = (e)=>e.preventDefault();
        document.addEventListener("dragover", onDocumentDragOver, false);
        document.addEventListener("drop", onDocumentDrop, false);
        return ()=>{
            document.removeEventListener("dragover", onDocumentDragOver, false);
            document.removeEventListener("drop", onDocumentDrop, false);
        };
    });
    const isPropagationStopped = (event)=>{
        if (typeof event.cancelBubble !== "undefined") {
            return event.cancelBubble;
        }
        return false;
    };
    const onDragEnter = (event)=>{
        event.preventDefault();
        dragTargets = [
            ...dragTargets,
            event.target
        ];
        if (core.isEventWithFiles(event)) {
            Promise.resolve(fileSelector.fromEvent(event)).then((files)=>{
                if (isPropagationStopped(event)) return;
                const fileCount = files.length;
                const isDragAccept = fileCount > 0 && core.allFilesAccepted({
                    files: files,
                    accept: store.get(acceptAttr),
                    minSize: store.get(props).minSize,
                    maxSize: store.get(props).maxSize,
                    multiple: store.get(props).multiple,
                    maxFiles: store.get(props).maxFiles
                });
                const isDragReject = fileCount > 0 && !isDragAccept;
                dispatch({
                    type: "setDraggedFiles",
                    payload: {
                        isDragAccept,
                        isDragReject,
                        isDragActive: true
                    }
                });
            }).catch(core.noop);
        }
    };
    const onDragOver = (event)=>{
        event.preventDefault();
        event.stopPropagation();
        const hasFiles = core.isEventWithFiles(event);
        if (hasFiles && event.dataTransfer) {
            try {
                event.dataTransfer.dropEffect = "copy";
            } catch  {
                core.noop();
            }
        }
        return false;
    };
    const onDragLeave = (event)=>{
        event.preventDefault();
        event.stopPropagation();
        const root = store.get(rootRef);
        // Only deactivate once the dropzone and all children have been left
        const targets = dragTargets.filter((target)=>root?.contains(target));
        // Make sure to remove a target present multiple times only once
        // (Firefox may fire dragenter/dragleave multiple times on the same element)
        const targetIdx = targets.indexOf(event.target);
        if (targetIdx !== -1) {
            targets.splice(targetIdx, 1);
        }
        dragTargets = targets;
        if (targets.length > 0) {
            return;
        }
        dispatch({
            type: "setDraggedFiles",
            payload: {
                isDragActive: false,
                isDragAccept: false,
                isDragReject: false
            }
        });
    };
    const setFiles = (files)=>{
        const acceptedFiles = [];
        files.forEach((file)=>{
            const accepted = core.isFileAccepted(file, store.get(acceptAttr));
            const sizeMatch = core.isValidSize(file, store.get(props).minSize, store.get(props).maxSize);
            if (accepted && sizeMatch) {
                acceptedFiles.push(file);
            }
        });
        if (!core.isValidQuantity(acceptedFiles, store.get(props).multiple, store.get(props).maxFiles)) {
            acceptedFiles.splice(0);
        }
        dispatch({
            type: "setFiles",
            payload: {
                acceptedFiles
            }
        });
        store.get(props).onDrop(acceptedFiles);
    };
    const onDropCb = (event)=>{
        event.preventDefault();
        dragTargets = [];
        if (core.isEventWithFiles(event)) {
            Promise.resolve(fileSelector.fromEvent(event)).then((files)=>{
                if (isPropagationStopped(event)) {
                    return;
                }
                setFiles(files);
            }).catch(core.noop);
        }
        dispatch({
            type: "reset"
        });
    };
    const openFileDialog = ()=>{
        const input = store.get(inputRef);
        if (input) {
            dispatch({
                type: "openDialog"
            });
            input.value = "";
            input.click();
        }
    };
    const onKeyDown = (event)=>{
        // Ignore keyboard events bubbling up the DOM tree
        const root = store.get(rootRef);
        if (!root?.isEqualNode(event.target)) {
            return;
        }
        if (core.isEnterOrSpace(event)) {
            event.preventDefault();
            openFileDialog();
        }
    };
    const onInputElementClick = (event)=>{
        event.stopPropagation();
    };
    const onFocus = ()=>dispatch({
            type: "focus"
        });
    const onBlur = ()=>dispatch({
            type: "blur"
        });
    const onClick = ()=>{
        // In IE11/Edge the file-browser dialog is blocking, therefore, use setTimeout()
        // to ensure React can handle state changes
        // See: https://github.com/react-dropzone/react-dropzone/issues/450
        core.isIeOrEdge() ? setTimeout(openFileDialog, 0) : openFileDialog();
    };
    // This is a svelte action, it should be used as "use:dropzoneRoot"
    // We should be able to refactor this when svelte 5 is released to bring it more inline
    // with the rest of the dropzone implementations
    const dropzoneRoot = (node)=>{
        rootRef.set(node);
        node.setAttribute("role", "presentation");
        if (!store.get(props).disabled) {
            node.setAttribute("tabIndex", "0");
            node.addEventListener("keydown", onKeyDown);
            node.addEventListener("focus", onFocus);
            node.addEventListener("blur", onBlur);
            node.addEventListener("click", onClick);
            node.addEventListener("dragenter", onDragEnter);
            node.addEventListener("dragover", onDragOver);
            node.addEventListener("dragleave", onDragLeave);
            node.addEventListener("drop", onDropCb);
        }
        return {
            destroy () {
                rootRef.set(null);
                node.removeEventListener("keydown", onKeyDown);
                node.removeEventListener("focus", onFocus);
                node.removeEventListener("blur", onBlur);
                node.removeEventListener("click", onClick);
                node.removeEventListener("dragenter", onDragEnter);
                node.removeEventListener("dragover", onDragOver);
                node.removeEventListener("dragleave", onDragLeave);
                node.removeEventListener("drop", onDropCb);
            }
        };
    };
    // This is a svelte action, it should be used as "use:dropzoneInput"
    const dropzoneInput = (node, options)=>{
        inputRef.set(node);
        node.setAttribute("type", "file");
        node.style.display = "none";
        node.setAttribute("multiple", String(options.multiple));
        node.setAttribute("tabIndex", "-1");
        const acceptAttrUnsub = acceptAttr.subscribe((accept)=>{
            node.setAttribute("accept", accept);
        });
        if (!options.disabled) {
            node.addEventListener("change", onDropCb);
            node.addEventListener("click", onInputElementClick);
        }
        return {
            update (options) {
                props.update(($props)=>({
                        ...$props,
                        ...options
                    }));
                node.setAttribute("multiple", String(options.multiple));
            },
            destroy () {
                inputRef.set(null);
                acceptAttrUnsub();
                node.removeEventListener("change", onDropCb);
                node.removeEventListener("click", onInputElementClick);
            }
        };
    };
    return {
        state,
        dropzoneRoot,
        dropzoneInput,
        rootRef
    };
}

exports.createDropzone = createDropzone;
