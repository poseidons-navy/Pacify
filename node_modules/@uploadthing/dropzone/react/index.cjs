Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var fileSelector = require('file-selector');
var core = require('@uploadthing/dropzone/core');

/**
 * A React hook that creates a drag 'n' drop area.
 *
 * ### Example
 *
 * ```tsx
 * function MyDropzone() {
 *   const { getRootProps, getInputProps } = useDropzone({
 *     onDrop: acceptedFiles => {
 *       // do something with the File objects, e.g. upload to some server
 *     }
 *   });
 *
 *   return (
 *     <div {...getRootProps()}>
 *       <input {...getInputProps()} />
 *       <p>Drag and drop some files here, or click to select files</p>
 *     </div>
 *   )
 * }
 * ```
 */ function useDropzone({ accept, disabled = false, maxSize = Number.POSITIVE_INFINITY, minSize = 0, multiple = true, maxFiles = 0, onDrop }) {
    const acceptAttr = react.useMemo(()=>core.acceptPropAsAcceptAttr(accept), [
        accept
    ]);
    const rootRef = react.useRef(null);
    const inputRef = react.useRef(null);
    const dragTargetsRef = react.useRef([]);
    const [state, dispatch] = react.useReducer(core.reducer, core.initialState);
    react.useEffect(()=>{
        // Update file dialog active state when the window is focused on
        const onWindowFocus = ()=>{
            // Execute the timeout only if the file dialog is opened in the browser
            if (state.isFileDialogActive) {
                setTimeout(()=>{
                    if (inputRef.current) {
                        const { files } = inputRef.current;
                        if (!files?.length) {
                            dispatch({
                                type: "closeDialog"
                            });
                        }
                    }
                }, 300);
            }
        };
        window.addEventListener("focus", onWindowFocus, false);
        return ()=>{
            window.removeEventListener("focus", onWindowFocus, false);
        };
    }, [
        state.isFileDialogActive
    ]);
    react.useEffect(()=>{
        const onDocumentDrop = (event)=>{
            // If we intercepted an event for our instance, let it propagate down to the instance's onDrop handler
            if (rootRef.current?.contains(event.target)) return;
            event.preventDefault();
            dragTargetsRef.current = [];
        };
        const onDocumentDragOver = (e)=>e.preventDefault();
        document.addEventListener("dragover", onDocumentDragOver, false);
        document.addEventListener("drop", onDocumentDrop, false);
        return ()=>{
            document.removeEventListener("dragover", onDocumentDragOver);
            document.removeEventListener("drop", onDocumentDrop);
        };
    }, []);
    const onDragEnter = react.useCallback((event)=>{
        event.preventDefault();
        event.persist();
        dragTargetsRef.current = [
            ...dragTargetsRef.current,
            event.target
        ];
        if (core.isEventWithFiles(event)) {
            Promise.resolve(fileSelector.fromEvent(event)).then((files)=>{
                if (event.isPropagationStopped()) return;
                const fileCount = files.length;
                const isDragAccept = fileCount > 0 && core.allFilesAccepted({
                    files: files,
                    accept: acceptAttr,
                    minSize,
                    maxSize,
                    multiple,
                    maxFiles
                });
                const isDragReject = fileCount > 0 && !isDragAccept;
                dispatch({
                    type: "setDraggedFiles",
                    payload: {
                        isDragAccept,
                        isDragReject,
                        isDragActive: true
                    }
                });
            }).catch(core.noop);
        }
    }, [
        acceptAttr,
        maxFiles,
        maxSize,
        minSize,
        multiple
    ]);
    const onDragOver = react.useCallback((event)=>{
        event.preventDefault();
        event.persist();
        const hasFiles = core.isEventWithFiles(event);
        if (hasFiles && event.dataTransfer !== null) {
            try {
                event.dataTransfer.dropEffect = "copy";
            } catch  {
                core.noop();
            }
        }
        return false;
    }, []);
    const onDragLeave = react.useCallback((event)=>{
        event.preventDefault();
        event.persist();
        // Only deactivate once the dropzone and all children have been left
        const targets = dragTargetsRef.current.filter((target)=>rootRef.current?.contains(target));
        // Make sure to remove a target present multiple times only once
        // (Firefox may fire dragenter/dragleave multiple times on the same element)
        const targetIdx = targets.indexOf(event.target);
        if (targetIdx !== -1) targets.splice(targetIdx, 1);
        dragTargetsRef.current = targets;
        if (targets.length > 0) return;
        dispatch({
            type: "setDraggedFiles",
            payload: {
                isDragActive: false,
                isDragAccept: false,
                isDragReject: false
            }
        });
    }, []);
    const setFiles = react.useCallback((files)=>{
        const acceptedFiles = [];
        files.forEach((file)=>{
            const accepted = core.isFileAccepted(file, acceptAttr);
            const sizeMatch = core.isValidSize(file, minSize, maxSize);
            if (accepted && sizeMatch) {
                acceptedFiles.push(file);
            }
        });
        if (!core.isValidQuantity(acceptedFiles, multiple, maxFiles)) {
            acceptedFiles.splice(0);
        }
        dispatch({
            type: "setFiles",
            payload: {
                acceptedFiles
            }
        });
        onDrop(acceptedFiles);
    }, [
        acceptAttr,
        maxFiles,
        maxSize,
        minSize,
        multiple,
        onDrop
    ]);
    const onDropCb = react.useCallback((event)=>{
        event.preventDefault();
        event.persist();
        dragTargetsRef.current = [];
        if (core.isEventWithFiles(event)) {
            Promise.resolve(fileSelector.fromEvent(event)).then((files)=>{
                if (event.isPropagationStopped()) return;
                setFiles(files);
            }).catch(core.noop);
        }
        dispatch({
            type: "reset"
        });
    }, [
        setFiles
    ]);
    const openFileDialog = react.useCallback(()=>{
        if (inputRef.current) {
            dispatch({
                type: "openDialog"
            });
            inputRef.current.value = "";
            inputRef.current.click();
        }
    }, []);
    // Cb to open the file dialog when SPACE/ENTER occurs on the dropzone
    const onKeyDown = react.useCallback((event)=>{
        // Ignore keyboard events bubbling up the DOM tree
        if (!rootRef.current?.isEqualNode(event.target)) return;
        if (core.isEnterOrSpace(event)) {
            event.preventDefault();
            openFileDialog();
        }
    }, [
        openFileDialog
    ]);
    const onInputElementClick = react.useCallback((e)=>{
        e.stopPropagation();
    }, []);
    // Update focus state for the dropzone
    const onFocus = react.useCallback(()=>dispatch({
            type: "focus"
        }), []);
    const onBlur = react.useCallback(()=>dispatch({
            type: "blur"
        }), []);
    const onClick = react.useCallback(()=>{
        // In IE11/Edge the file-browser dialog is blocking, therefore,
        // use setTimeout() to ensure React can handle state changes
        core.isIeOrEdge() ? setTimeout(openFileDialog, 0) : openFileDialog();
    }, [
        openFileDialog
    ]);
    const getRootProps = react.useMemo(()=>()=>({
                ref: rootRef,
                role: "presentation",
                ...!disabled ? {
                    tabIndex: 0,
                    onKeyDown,
                    onFocus,
                    onBlur,
                    onClick,
                    onDragEnter,
                    onDragOver,
                    onDragLeave,
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    onDrop: onDropCb
                } : {}
            }), [
        disabled,
        onBlur,
        onClick,
        onDragEnter,
        onDragLeave,
        onDragOver,
        onDropCb,
        onFocus,
        onKeyDown
    ]);
    const getInputProps = react.useMemo(()=>()=>({
                ref: inputRef,
                type: "file",
                style: {
                    display: "none"
                },
                accept: acceptAttr,
                multiple,
                tabIndex: -1,
                ...!disabled ? {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    onChange: onDropCb,
                    onClick: onInputElementClick
                } : {}
            }), [
        acceptAttr,
        multiple,
        onDropCb,
        onInputElementClick,
        disabled
    ]);
    return {
        ...state,
        getRootProps,
        getInputProps,
        rootRef
    };
}

exports.useDropzone = useDropzone;
