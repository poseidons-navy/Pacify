Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var shared = require('@uploadthing/shared');
var client = require('uploadthing/client');
var react = require('@uploadthing/dropzone/react');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

var peerDependencies = {
	next: "*",
	react: "^17.0.2 || ^18.0.0",
	uploadthing: "^6.5.1"
};

// Ripped from https://github.com/scottrippey/react-use-event-hook
const noop = ()=>void 0;
/**
 * Suppress the warning when using useLayoutEffect with SSR. (https://reactjs.org/link/uselayouteffect-ssr)
 * Make use of useInsertionEffect if available.
 */ const useInsertionEffect = typeof window !== "undefined" ? React__default.default.useInsertionEffect || React__default.default.useLayoutEffect : noop;
/**
 * Similar to useCallback, with a few subtle differences:
 * - The returned function is a stable reference, and will always be the same between renders
 * - No dependency lists required
 * - Properties or state accessed within the callback will always be "current"
 */ function useEvent(callback) {
    // Keep track of the latest callback:
    const latestRef = React__default.default.useRef(// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    useEvent_shouldNotBeInvokedBeforeMount);
    useInsertionEffect(()=>{
        latestRef.current = callback;
    }, [
        callback
    ]);
    // Create a stable callback that always calls the latest callback:
    // using useRef instead of useCallback avoids creating and empty array on every render
    const stableRef = React__default.default.useRef();
    if (!stableRef.current) {
        stableRef.current = function() {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return, prefer-rest-params, @typescript-eslint/no-unsafe-argument
            return latestRef.current.apply(this, arguments);
        };
    }
    return stableRef.current;
}
/**
 * Render methods should be pure, especially when concurrency is used,
 * so we will throw this error if the callback is called while rendering.
 */ function useEvent_shouldNotBeInvokedBeforeMount() {
    throw new Error("INVALID_USEEVENT_INVOCATION: the callback from useEvent cannot be invoked before the component has mounted.");
}

// Ripped from https://usehooks-ts.com/react-hook/use-fetch
function useFetch(url, options) {
    const cache = React.useRef({});
    // Used to prevent state update if the component is unmounted
    const cancelRequest = React.useRef(false);
    const initialState = {
        error: undefined,
        data: undefined
    };
    // Keep state logic separated
    const fetchReducer = (state, action)=>{
        switch(action.type){
            case "loading":
                return {
                    ...initialState
                };
            case "fetched":
                return {
                    ...initialState,
                    data: action.payload
                };
            case "error":
                return {
                    ...initialState,
                    error: action.payload
                };
            default:
                return state;
        }
    };
    const [state, dispatch] = React.useReducer(fetchReducer, initialState);
    React.useEffect(()=>{
        // Do nothing if the url is not given
        if (!url) return;
        cancelRequest.current = false;
        const fetchData = async ()=>{
            dispatch({
                type: "loading"
            });
            // If a cache exists for this url, return it
            if (cache.current[url]) {
                dispatch({
                    type: "fetched",
                    payload: cache.current[url]
                });
                return;
            }
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(response.statusText);
                }
                const dataOrError = await shared.safeParseJSON(response);
                if (dataOrError instanceof Error) {
                    throw dataOrError;
                }
                cache.current[url] = dataOrError;
                if (cancelRequest.current) return;
                dispatch({
                    type: "fetched",
                    payload: dataOrError
                });
            } catch (error) {
                if (cancelRequest.current) return;
                dispatch({
                    type: "error",
                    payload: error
                });
            }
        };
        void fetchData();
        // Use the cleanup function for avoiding a possibly...
        // ...state update after the component was unmounted
        return ()=>{
            cancelRequest.current = true;
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        url
    ]);
    return state;
}

const useEndpointMetadata = (url, endpoint)=>{
    const maybeServerData = globalThis.__UPLOADTHING;
    const { data } = useFetch(// Don't fetch if we already have the data
    maybeServerData ? undefined : url.href);
    return (maybeServerData ?? data)?.find((x)=>x.slug === endpoint);
};
const INTERNAL_uploadthingHookGen = (initOpts)=>{
    if (!shared.semverLite(peerDependencies.uploadthing, client.version)) {
        console.error(`!!!WARNING::: @uploadthing/react requires "uploadthing@${peerDependencies.uploadthing}", but version "${client.version}" is installed`);
    }
    const uploadFiles = client.genUploader({
        url: initOpts.url,
        package: "@uploadthing/react"
    });
    const useUploadThing = (endpoint, opts)=>{
        const [isUploading, setUploading] = React.useState(false);
        const uploadProgress = React.useRef(0);
        const fileProgress = React.useRef(new Map());
        const permittedFileInfo = useEndpointMetadata(initOpts.url, endpoint);
        const startUpload = useEvent(async (...args)=>{
            const files = await opts?.onBeforeUploadBegin?.(args[0]) ?? args[0];
            const input = args[1];
            setUploading(true);
            opts?.onUploadProgress?.(0);
            try {
                const res = await uploadFiles(endpoint, {
                    headers: opts?.headers,
                    files,
                    skipPolling: opts?.skipPolling,
                    onUploadProgress: (progress)=>{
                        if (!opts?.onUploadProgress) return;
                        fileProgress.current.set(progress.file, progress.progress);
                        let sum = 0;
                        fileProgress.current.forEach((p)=>{
                            sum += p;
                        });
                        const averageProgress = Math.floor(sum / fileProgress.current.size / 10) * 10;
                        if (averageProgress !== uploadProgress.current) {
                            opts?.onUploadProgress?.(averageProgress);
                            uploadProgress.current = averageProgress;
                        }
                    },
                    onUploadBegin ({ file }) {
                        if (!opts?.onUploadBegin) return;
                        opts.onUploadBegin(file);
                    },
                    // @ts-expect-error - input may not be defined on the type
                    input
                });
                opts?.onClientUploadComplete?.(res);
                return res;
            } catch (e) {
                let error;
                if (e instanceof shared.UploadThingError) {
                    error = e;
                } else {
                    error = shared.INTERNAL_DO_NOT_USE__fatalClientError(e);
                    console.error("Something went wrong. Please contact UploadThing and provide the following cause:", error.cause instanceof Error ? error.cause.toString() : error.cause);
                }
                opts?.onUploadError?.(error);
            } finally{
                setUploading(false);
                fileProgress.current = new Map();
                uploadProgress.current = 0;
            }
        });
        return {
            startUpload,
            isUploading,
            permittedFileInfo
        };
    };
    return useUploadThing;
};
const generateReactHelpers = (initOpts)=>{
    const url = shared.resolveMaybeUrlArg(initOpts?.url);
    return {
        useUploadThing: INTERNAL_uploadthingHookGen({
            url
        }),
        uploadFiles: client.genUploader({
            url,
            package: "@uploadthing/react"
        })
    };
};

Object.defineProperty(exports, "useDropzone", {
  enumerable: true,
  get: function () { return react.useDropzone; }
});
exports.generateReactHelpers = generateReactHelpers;
