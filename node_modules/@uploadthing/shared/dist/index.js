import { process } from 'std-env';
import { lookup } from '@uploadthing/mime-types';

function isRouteArray(routeConfig) {
    return Array.isArray(routeConfig);
}
function getDefaultSizeForType(fileType) {
    if (fileType === "image") return "4MB";
    if (fileType === "video") return "16MB";
    if (fileType === "audio") return "8MB";
    if (fileType === "blob") return "8MB";
    if (fileType === "pdf") return "4MB";
    if (fileType === "text") return "64KB";
    return "4MB";
}
/**
 * This function takes in the user's input and "upscales" it to a full config
 *
 * Example:
 * ```ts
 * ["image"] => { image: { maxFileSize: "4MB", limit: 1 } }
 * ```
 */ function fillInputRouteConfig(routeConfig) {
    // If array, apply defaults
    if (isRouteArray(routeConfig)) {
        return routeConfig.reduce((acc, fileType)=>{
            acc[fileType] = {
                // Apply defaults
                maxFileSize: getDefaultSizeForType(fileType),
                maxFileCount: 1,
                minFileCount: 1,
                contentDisposition: "inline"
            };
            return acc;
        }, {});
    }
    // Backfill defaults onto config
    const newConfig = {};
    const inputKeys = objectKeys(routeConfig);
    inputKeys.forEach((key)=>{
        const value = routeConfig[key];
        if (!value) throw new Error("Invalid config during fill");
        const defaultValues = {
            maxFileSize: getDefaultSizeForType(key),
            maxFileCount: 1,
            minFileCount: 1,
            contentDisposition: "inline"
        };
        newConfig[key] = {
            ...defaultValues,
            ...value
        };
    }, {});
    return newConfig;
}
function getTypeFromFileName(fileName, allowedTypes) {
    const mimeType = lookup(fileName);
    if (!mimeType) {
        if (allowedTypes.includes("blob")) return "blob";
        throw new Error(`Could not determine type for ${fileName}, presigned URL generation failed`);
    }
    // If the user has specified a specific mime type, use that
    if (allowedTypes.some((type)=>type.includes("/"))) {
        if (allowedTypes.includes(mimeType)) {
            return mimeType;
        }
    }
    // Otherwise, we have a "magic" type eg. "image" or "video"
    const type = mimeType.toLowerCase() === "application/pdf" ? "pdf" : mimeType.split("/")[0];
    if (!allowedTypes.includes(type)) {
        // Blob is a catch-all for any file type not explicitly supported
        if (allowedTypes.includes("blob")) {
            return "blob";
        } else {
            throw new Error(`File type ${type} not allowed for ${fileName}`);
        }
    }
    return type;
}
function generateUploadThingURL(path) {
    let host = "https://uploadthing.com";
    if (process.env.CUSTOM_INFRA_URL) {
        host = process.env.CUSTOM_INFRA_URL;
    }
    return `${host}${path}`;
}
/**
 * RETURN UNDEFINED TO KEEP GOING
 * SO MAKE SURE YOUR FUNCTION RETURNS SOMETHING
 * OTHERWISE IT'S AN IMPLICIT UNDEFINED AND WILL CAUSE
 * AN INFINITE LOOP
 */ const withExponentialBackoff = async (doTheThing, MAXIMUM_BACKOFF_MS = 64 * 1000, MAX_RETRIES = 20)=>{
    let tries = 0;
    let backoffMs = 500;
    let backoffFuzzMs = 0;
    let result = undefined;
    while(tries <= MAX_RETRIES){
        result = await doTheThing();
        if (result !== undefined) return result;
        tries += 1;
        backoffMs = Math.min(MAXIMUM_BACKOFF_MS, backoffMs * 2);
        backoffFuzzMs = Math.floor(Math.random() * 500);
        if (tries > 3) {
            console.error(`[UT] Call unsuccessful after ${tries} tries. Retrying in ${Math.floor(backoffMs / 1000)} seconds...`);
        }
        await new Promise((r)=>setTimeout(r, backoffMs + backoffFuzzMs));
    }
    return null;
};
async function pollForFileData(opts, callback) {
    return withExponentialBackoff(async ()=>{
        const res = await opts.fetch(opts.url, {
            headers: {
                ...opts.apiKey && {
                    "x-uploadthing-api-key": opts.apiKey
                },
                "x-uploadthing-version": opts.sdkVersion
            }
        });
        const maybeJson = await safeParseJSON(res);
        if (maybeJson instanceof Error) {
            console.error(`[UT] Error polling for file data for ${opts.url}: ${maybeJson.message}`);
            return null;
        }
        if (maybeJson.status !== "done") return undefined;
        await callback?.(maybeJson);
        return Symbol("backoff done without response");
    });
}
const FILESIZE_UNITS = [
    "B",
    "KB",
    "MB",
    "GB"
];
const fileSizeToBytes = (input)=>{
    const regex = new RegExp(`^(\\d+)(\\.\\d+)?\\s*(${FILESIZE_UNITS.join("|")})$`, "i");
    const match = input.match(regex);
    if (!match) {
        return new Error("Invalid file size format");
    }
    const sizeValue = parseFloat(match[1]);
    const sizeUnit = match[3].toUpperCase();
    if (!FILESIZE_UNITS.includes(sizeUnit)) {
        throw new Error("Invalid file size unit");
    }
    const bytes = sizeValue * Math.pow(1024, FILESIZE_UNITS.indexOf(sizeUnit));
    return Math.floor(bytes);
};
async function safeParseJSON(input) {
    if (typeof input === "string") {
        try {
            return JSON.parse(input);
        } catch (err) {
            console.error(`Error parsing JSON, got '${input}'`);
            return new Error(`Error parsing JSON, got '${input}'`);
        }
    }
    const text = await input.text();
    try {
        return JSON.parse(text ?? "null");
    } catch (err) {
        console.error(`Error parsing JSON, got '${text}'`);
        return new Error(`Error parsing JSON, got '${text}'`);
    }
}
/** typesafe Object.keys */ function objectKeys(obj) {
    return Object.keys(obj);
}
/** checks if obj is a valid, non-null object */ function isObject(obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
function asArray(val) {
    return Array.isArray(val) ? val : [
        val
    ];
}
/** construct content-disposition header */ function contentDisposition(contentDisposition, fileName) {
    return [
        contentDisposition,
        `filename="${encodeURI(fileName)}"`,
        `filename*=UTF-8''${encodeURI(fileName)}`
    ].join("; ");
}
function semverLite(required, toCheck) {
    // Pull out numbers from strings like `6.0.0`, `^6.4`, `~6.4.0`
    const semverRegex = /(\d+)\.?(\d+)?\.?(\d+)?/;
    const requiredMatch = required.match(semverRegex);
    if (!requiredMatch?.[0]) {
        throw new Error(`Invalid semver requirement: ${required}`);
    }
    const toCheckMatch = toCheck.match(semverRegex);
    if (!toCheckMatch?.[0]) {
        throw new Error(`Invalid semver to check: ${toCheck}`);
    }
    const [_1, rMajor, rMinor, rPatch] = requiredMatch;
    const [_2, cMajor, cMinor, cPatch] = toCheckMatch;
    if (required.startsWith("^")) {
        // Major must be equal, minor must be greater or equal
        if (rMajor !== cMajor) return false;
        if (rMinor > cMinor) return false;
        return true;
    }
    if (required.startsWith("~")) {
        // Major must be equal, minor must be equal
        if (rMajor !== cMajor) return false;
        if (rMinor !== cMinor) return false;
        return true;
    }
    // Exact match
    return rMajor === cMajor && rMinor === cMinor && rPatch === cPatch;
}
function getFullApiUrl(maybeUrl) {
    const base = (()=>{
        if (typeof window !== "undefined") return window.location.origin;
        if (process.env?.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;
        return "http://localhost:3000";
    })();
    try {
        const url = new URL(maybeUrl ?? "/api/uploadthing", base);
        if (url.pathname === "/") {
            url.pathname = "/api/uploadthing";
        }
        return url;
    } catch (err) {
        throw new Error(`Failed to parse '${maybeUrl}' as a URL. Make sure it's a valid URL or path`);
    }
}
/*
 * Returns a full URL to the dev's uploadthing endpoint
 * Can take either an origin, or a pathname, or a full URL
 * and will return the "closest" url matching the default
 * `<VERCEL_URL || localhost>/api/uploadthing`
 */ function resolveMaybeUrlArg(maybeUrl) {
    return maybeUrl instanceof URL ? maybeUrl : getFullApiUrl(maybeUrl);
}

const ALLOWED_FILE_TYPES = [
    "image",
    "video",
    "audio",
    "pdf",
    "text",
    "blob"
];

const ERROR_CODES = {
    // Generic
    BAD_REQUEST: 400,
    NOT_FOUND: 404,
    FORBIDDEN: 403,
    INTERNAL_SERVER_ERROR: 500,
    INTERNAL_CLIENT_ERROR: 500,
    // S3 specific
    TOO_LARGE: 413,
    TOO_SMALL: 400,
    TOO_MANY_FILES: 400,
    KEY_TOO_LONG: 400,
    // UploadThing specific
    URL_GENERATION_FAILED: 500,
    UPLOAD_FAILED: 500,
    MISSING_ENV: 500,
    FILE_LIMIT_EXCEEDED: 500
};
function messageFromUnknown(cause, fallback) {
    if (typeof cause === "string") {
        return cause;
    }
    if (cause instanceof Error) {
        return cause.message;
    }
    if (cause && typeof cause === "object" && "message" in cause && typeof cause.message === "string") {
        return cause.message;
    }
    return fallback ?? "An unknown error occurred";
}
class UploadThingError extends Error {
    constructor(initOpts){
        const opts = typeof initOpts === "string" ? {
            code: "INTERNAL_SERVER_ERROR",
            message: initOpts
        } : initOpts;
        const message = opts.message ?? messageFromUnknown(opts.cause, opts.code);
        super(message);
        this.code = opts.code;
        this.data = opts.data;
        if (opts.cause instanceof Error) {
            this.cause = opts.cause;
        } else if (opts.cause instanceof Response) {
            this.cause = new Error(`Response ${opts.cause.status} ${opts.cause.statusText}`);
        } else if (typeof opts.cause === "string") {
            this.cause = new Error(opts.cause);
        } else {
            this.cause = opts.cause;
        }
    }
    static async fromResponse(response) {
        const jsonOrError = await safeParseJSON(response);
        if (jsonOrError instanceof Error) {
            return new UploadThingError({
                message: jsonOrError.message,
                code: getErrorTypeFromStatusCode(response.status),
                cause: response
            });
        }
        let message = undefined;
        if (isObject(jsonOrError)) {
            if (typeof jsonOrError.message === "string") {
                message = jsonOrError.message;
            } else if (typeof jsonOrError.error === "string") {
                message = jsonOrError.error;
            }
        }
        return new UploadThingError({
            message,
            code: getErrorTypeFromStatusCode(response.status),
            cause: response,
            data: jsonOrError
        });
    }
    static toObject(error) {
        return {
            code: error.code,
            message: error.message,
            data: error.data
        };
    }
    static serialize(error) {
        return JSON.stringify(UploadThingError.toObject(error));
    }
}
function getStatusCodeFromError(error) {
    return ERROR_CODES[error.code] ?? 500;
}
function getErrorTypeFromStatusCode(statusCode) {
    for (const [code, status] of Object.entries(ERROR_CODES)){
        if (status === statusCode) {
            return code;
        }
    }
    return "INTERNAL_SERVER_ERROR";
}
const INTERNAL_DO_NOT_USE__fatalClientError = (e)=>new UploadThingError({
        code: "INTERNAL_CLIENT_ERROR",
        message: "Something went wrong. Please report this to UploadThing.",
        cause: e
    });

const generateMimeTypes = (fileTypes)=>{
    const accepted = fileTypes.map((type)=>{
        if (type === "blob") return "blob";
        if (type === "pdf") return "application/pdf";
        if (type.includes("/")) return type;
        else return `${type}/*`;
    });
    if (accepted.includes("blob")) {
        return undefined;
    }
    return accepted;
};
const generateClientDropzoneAccept = (fileTypes)=>{
    const mimeTypes = generateMimeTypes(fileTypes);
    if (!mimeTypes) return undefined;
    return Object.fromEntries(mimeTypes.map((type)=>[
            type,
            []
        ]));
};
/**
 * Shared helpers for our premade components that's reusable by multiple frameworks
 */ const generatePermittedFileTypes = (config)=>{
    const fileTypes = config ? objectKeys(config) : [];
    const maxFileCount = config ? Object.values(config).map((v)=>v.maxFileCount) : [];
    return {
        fileTypes,
        multiple: maxFileCount.some((v)=>v && v > 1)
    };
};
const capitalizeStart = (str)=>{
    return str.charAt(0).toUpperCase() + str.slice(1);
};
const INTERNAL_doFormatting = (config)=>{
    if (!config) return "";
    const allowedTypes = objectKeys(config);
    const formattedTypes = allowedTypes.map((f)=>f === "blob" ? "file" : f);
    // Format multi-type uploader label as "Supports videos, images and files";
    if (formattedTypes.length > 1) {
        const lastType = formattedTypes.pop();
        return `${formattedTypes.join("s, ")} and ${lastType}s`;
    }
    // Single type uploader label
    const key = allowedTypes[0];
    const formattedKey = formattedTypes[0];
    const { maxFileSize, maxFileCount, minFileCount } = config[key];
    if (maxFileCount && maxFileCount > 1) {
        if (minFileCount > 1) {
            return `${minFileCount} - ${maxFileCount} ${formattedKey}s up to ${maxFileSize}`;
        } else {
            return `${formattedKey}s up to ${maxFileSize}, max ${maxFileCount}`;
        }
    } else {
        return `${formattedKey} (${maxFileSize})`;
    }
};
const allowedContentTextLabelGenerator = (config)=>{
    return capitalizeStart(INTERNAL_doFormatting(config));
};
const styleFieldToClassName = (styleField, args)=>{
    if (typeof styleField === "string") return styleField;
    if (typeof styleField === "function") {
        const result = styleField(args);
        if (typeof result === "string") return result;
    }
    return "";
};
const styleFieldToCssObject = (styleField, args)=>{
    if (typeof styleField === "object") return styleField;
    if (typeof styleField === "function") {
        const result = styleField(args);
        if (typeof result === "object") return result;
    }
    return {};
};
const contentFieldToContent = (contentField, arg)=>{
    if (!contentField) return null;
    if (typeof contentField !== "function") return contentField;
    if (typeof contentField === "function") {
        const result = contentField(arg);
        return result;
    }
};

const signaturePrefix = "hmac-sha256=";
const algorithm = {
    name: "HMAC",
    hash: "SHA-256"
};
const signPayload = async (payload, secret)=>{
    const encoder = new TextEncoder();
    const signingKey = await crypto.subtle.importKey("raw", encoder.encode(secret), algorithm, false, [
        "sign"
    ]);
    const signature = await crypto.subtle.sign(algorithm, signingKey, encoder.encode(payload)).then((sig)=>Buffer.from(sig).toString("hex"));
    return `${signaturePrefix}${signature}`;
};
const verifySignature = async (payload, signature, secret)=>{
    const sig = signature?.slice(signaturePrefix.length);
    if (!sig) return false;
    const encoder = new TextEncoder();
    const signingKey = await crypto.subtle.importKey("raw", encoder.encode(secret), algorithm, false, [
        "verify"
    ]);
    return await crypto.subtle.verify(algorithm, signingKey, Uint8Array.from(Buffer.from(sig, "hex")), encoder.encode(payload));
};

export { ALLOWED_FILE_TYPES, FILESIZE_UNITS, INTERNAL_DO_NOT_USE__fatalClientError, INTERNAL_doFormatting, UploadThingError, allowedContentTextLabelGenerator, asArray, capitalizeStart, contentDisposition, contentFieldToContent, fileSizeToBytes, fillInputRouteConfig, generateClientDropzoneAccept, generateMimeTypes, generatePermittedFileTypes, generateUploadThingURL, getDefaultSizeForType, getStatusCodeFromError, getTypeFromFileName, isObject, isRouteArray, objectKeys, pollForFileData, resolveMaybeUrlArg, safeParseJSON, semverLite, signPayload, styleFieldToClassName, styleFieldToCssObject, verifySignature, withExponentialBackoff };
